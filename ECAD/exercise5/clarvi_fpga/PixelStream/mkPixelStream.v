//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Tue Nov  3 17:49:28 GMT 2015
//
//
// Ports:
// Name                         I/O  size props
// avs_s0_readdata                O    32
// avs_s0_waitrequest             O     1
// avm_m0_writedata               O    32 reg
// avm_m0_address                 O    31 reg
// avm_m0_read                    O     1 reg
// avm_m0_write                   O     1 reg
// avm_m0_burstcount              O     1 reg
// coe_hdmi_r                     O     8 reg
// coe_hdmi_g                     O     8 reg
// coe_hdmi_b                     O     8 reg
// coe_hdmi_hsd                   O     1 reg
// coe_hdmi_vsd                   O     1 reg
// coe_hdmi_de                    O     1 reg
// csi_clockreset_clk_coe_hdmi_dclk  O     1
// CLK_GATE_coe_hdmi_dclk         O     1 const
// csi_video_clk                  I     1
// csi_clockreset_clk             I     1 clock
// csi_clockreset_reset_n         I     1 reset
// avs_s0_address                 I     4 reg
// avs_s0_writedata               I    32 reg
// avs_s0_write                   I     1
// avs_s0_read                    I     1
// avm_m0_readdata                I    32 reg
// avm_m0_readdatavalid           I     1
// avm_m0_waitrequest             I     1
//
// Combinational paths from inputs to outputs:
//   (avs_s0_write, avs_s0_read) -> avs_s0_waitrequest
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkPixelStream(csi_video_clk,
		     csi_clockreset_clk,
		     csi_clockreset_reset_n,

		     avs_s0_address,
		     avs_s0_writedata,
		     avs_s0_write,
		     avs_s0_read,

		     avs_s0_readdata,

		     avs_s0_waitrequest,

		     avm_m0_readdata,
		     avm_m0_readdatavalid,
		     avm_m0_waitrequest,

		     avm_m0_writedata,

		     avm_m0_address,

		     avm_m0_read,

		     avm_m0_write,

		     avm_m0_burstcount,

		     coe_hdmi_r,

		     coe_hdmi_g,

		     coe_hdmi_b,

		     coe_hdmi_hsd,

		     coe_hdmi_vsd,

		     coe_hdmi_de,

		     csi_clockreset_clk_coe_hdmi_dclk,
		     CLK_GATE_coe_hdmi_dclk);
  input  csi_video_clk;
  input  csi_clockreset_clk;
  input  csi_clockreset_reset_n;

  // action method avs_s0
  input  [3 : 0] avs_s0_address;
  input  [31 : 0] avs_s0_writedata;
  input  avs_s0_write;
  input  avs_s0_read;

  // value method avs_s0_readdata
  output [31 : 0] avs_s0_readdata;

  // value method avs_s0_waitrequest
  output avs_s0_waitrequest;

  // action method avm_m0
  input  [31 : 0] avm_m0_readdata;
  input  avm_m0_readdatavalid;
  input  avm_m0_waitrequest;

  // value method avm_m0_writedata
  output [31 : 0] avm_m0_writedata;

  // value method avm_m0_address
  output [30 : 0] avm_m0_address;

  // value method avm_m0_read
  output avm_m0_read;

  // value method avm_m0_write
  output avm_m0_write;

  // value method avm_m0_burstcount
  output avm_m0_burstcount;

  // value method coe_hdmi_r
  output [7 : 0] coe_hdmi_r;

  // value method coe_hdmi_g
  output [7 : 0] coe_hdmi_g;

  // value method coe_hdmi_b
  output [7 : 0] coe_hdmi_b;

  // value method coe_hdmi_hsd
  output coe_hdmi_hsd;

  // value method coe_hdmi_vsd
  output coe_hdmi_vsd;

  // value method coe_hdmi_de
  output coe_hdmi_de;

  // oscillator and gates for output clock csi_clockreset_clk_coe_hdmi_dclk
  output csi_clockreset_clk_coe_hdmi_dclk;
  output CLK_GATE_coe_hdmi_dclk;

  // signals for module outputs
  wire [31 : 0] avm_m0_writedata, avs_s0_readdata;
  wire [30 : 0] avm_m0_address;
  wire [7 : 0] coe_hdmi_b, coe_hdmi_g, coe_hdmi_r;
  wire CLK_GATE_coe_hdmi_dclk,
       avm_m0_burstcount,
       avm_m0_read,
       avm_m0_write,
       avs_s0_waitrequest,
       coe_hdmi_de,
       coe_hdmi_hsd,
       coe_hdmi_vsd,
       csi_clockreset_clk_coe_hdmi_dclk;

  // inlined wires
  wire vparams_mmap_slave_avalonwait$wget,
       vparams_mmap_slave_avalonwait_end_read$whas,
       vparams_mmap_slave_avalonwait_end_write$whas;

  // register hdmi_de
  reg hdmi_de;
  wire hdmi_de$D_IN, hdmi_de$EN;

  // register hdmi_hsd
  reg hdmi_hsd;
  wire hdmi_hsd$D_IN, hdmi_hsd$EN;

  // register hdmi_output_on
  reg hdmi_output_on;
  wire hdmi_output_on$D_IN, hdmi_output_on$EN;

  // register hdmi_pixel_out
  reg [24 : 0] hdmi_pixel_out;
  wire [24 : 0] hdmi_pixel_out$D_IN;
  wire hdmi_pixel_out$EN;

  // register hdmi_vsd
  reg hdmi_vsd;
  wire hdmi_vsd$D_IN, hdmi_vsd$EN;

  // register hdmi_x
  reg [15 : 0] hdmi_x;
  wire [15 : 0] hdmi_x$D_IN;
  wire hdmi_x$EN;

  // register hdmi_y
  reg [15 : 0] hdmi_y;
  wire [15 : 0] hdmi_y$D_IN;
  wire hdmi_y$EN;

  // register num_pixels
  reg [31 : 0] num_pixels;
  wire [31 : 0] num_pixels$D_IN;
  wire num_pixels$EN;

  // register vparams_base
  reg [63 : 0] vparams_base;
  wire [63 : 0] vparams_base$D_IN;
  wire vparams_base$EN;

  // register vparams_mmap_slave_ignore_further_requests
  reg vparams_mmap_slave_ignore_further_requests;
  wire vparams_mmap_slave_ignore_further_requests$D_IN,
       vparams_mmap_slave_ignore_further_requests$EN;

  // register vparams_p_0
  reg [15 : 0] vparams_p_0;
  wire [15 : 0] vparams_p_0$D_IN;
  wire vparams_p_0$EN;

  // register vparams_p_1
  reg [15 : 0] vparams_p_1;
  wire [15 : 0] vparams_p_1$D_IN;
  wire vparams_p_1$EN;

  // register vparams_p_2
  reg [15 : 0] vparams_p_2;
  wire [15 : 0] vparams_p_2$D_IN;
  wire vparams_p_2$EN;

  // register vparams_p_3
  reg [15 : 0] vparams_p_3;
  wire [15 : 0] vparams_p_3$D_IN;
  wire vparams_p_3$EN;

  // register vparams_p_4
  reg [15 : 0] vparams_p_4;
  wire [15 : 0] vparams_p_4$D_IN;
  wire vparams_p_4$EN;

  // register vparams_p_5
  reg [15 : 0] vparams_p_5;
  wire [15 : 0] vparams_p_5$D_IN;
  wire vparams_p_5$EN;

  // register vparams_p_6
  reg [15 : 0] vparams_p_6;
  wire [15 : 0] vparams_p_6$D_IN;
  wire vparams_p_6$EN;

  // register vparams_p_7
  reg [15 : 0] vparams_p_7;
  wire [15 : 0] vparams_p_7$D_IN;
  wire vparams_p_7$EN;

  // ports of submodule burst_read
  wire [63 : 0] burst_read$params_base;
  wire [31 : 0] burst_read$avalon_master_phy_m0_readdata,
		burst_read$avalon_master_phy_m0_writedata,
		burst_read$params_number_pixels;
  wire [30 : 0] burst_read$avalon_master_phy_m0_address;
  wire [24 : 0] burst_read$pixel_stream_get;
  wire burst_read$EN_params,
       burst_read$EN_pixel_stream_get,
       burst_read$RDY_pixel_stream_get,
       burst_read$avalon_master_phy_m0_burstcount,
       burst_read$avalon_master_phy_m0_read,
       burst_read$avalon_master_phy_m0_readdatavalid,
       burst_read$avalon_master_phy_m0_waitrequest,
       burst_read$avalon_master_phy_m0_write;

  // ports of submodule hdmi_pixel_buf
  wire [24 : 0] hdmi_pixel_buf$D_IN, hdmi_pixel_buf$D_OUT;
  wire hdmi_pixel_buf$CLR,
       hdmi_pixel_buf$DEQ,
       hdmi_pixel_buf$EMPTY_N,
       hdmi_pixel_buf$ENQ,
       hdmi_pixel_buf$FULL_N;

  // ports of submodule pix_sync
  wire [24 : 0] pix_sync$dD_OUT, pix_sync$sD_IN;
  wire pix_sync$dDEQ, pix_sync$dEMPTY_N, pix_sync$sENQ, pix_sync$sFULL_N;

  // ports of submodule vidrst
  wire vidrst$OUT_RST;

  // ports of submodule vp_sync
  wire [127 : 0] vp_sync$dD_OUT, vp_sync$sD_IN;
  wire vp_sync$sEN, vp_sync$sRDY;

  // ports of submodule vparams_mmap_slave_outbuf
  wire [37 : 0] vparams_mmap_slave_outbuf$D_IN,
		vparams_mmap_slave_outbuf$D_OUT;
  wire vparams_mmap_slave_outbuf$CLR,
       vparams_mmap_slave_outbuf$DEQ,
       vparams_mmap_slave_outbuf$EMPTY_N,
       vparams_mmap_slave_outbuf$ENQ,
       vparams_mmap_slave_outbuf$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_forward_burst_params,
       CAN_FIRE_RL_forward_parameters_local_clock,
       CAN_FIRE_RL_forward_parameters_video_clock,
       CAN_FIRE_RL_hdmi_init,
       CAN_FIRE_RL_hdmi_scan,
       CAN_FIRE_RL_mkConnectionGetPut,
       CAN_FIRE_RL_mkConnectionGetPut_1,
       CAN_FIRE_RL_vparams_handle_avalon_accesses,
       CAN_FIRE_RL_vparams_mmap_slave_cancel_ingore_further_requests,
       CAN_FIRE_RL_vparams_mmap_slave_hanlde_bus_requests,
       CAN_FIRE_RL_vparams_mmap_slave_wire_up_avalonwait,
       CAN_FIRE_avm_m0,
       CAN_FIRE_avs_s0,
       WILL_FIRE_RL_forward_burst_params,
       WILL_FIRE_RL_forward_parameters_local_clock,
       WILL_FIRE_RL_forward_parameters_video_clock,
       WILL_FIRE_RL_hdmi_init,
       WILL_FIRE_RL_hdmi_scan,
       WILL_FIRE_RL_mkConnectionGetPut,
       WILL_FIRE_RL_mkConnectionGetPut_1,
       WILL_FIRE_RL_vparams_handle_avalon_accesses,
       WILL_FIRE_RL_vparams_mmap_slave_cancel_ingore_further_requests,
       WILL_FIRE_RL_vparams_mmap_slave_hanlde_bus_requests,
       WILL_FIRE_RL_vparams_mmap_slave_wire_up_avalonwait,
       WILL_FIRE_avm_m0,
       WILL_FIRE_avs_s0;

  // remaining internal signals
  reg [63 : 0] v__h1935, v__h3787;
  reg [31 : 0] CASE_vparams_mmap_slave_outbufD_OUT_BITS_35_T_ETC__q1;
  reg [15 : 0] x__h2347;
  wire [63 : 0] SEXT_vparams_p_0_6_74_MUL_SEXT_vparams_p_4_0_75___d176,
		x__h2024,
		x__h2113;
  wire [31 : 0] b__h4883;
  wire [7 : 0] IF_NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_h_ETC___d152,
	       IF_NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_h_ETC___d155,
	       IF_NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_h_ETC___d158;
  wire NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_hdmi_ETC___d145,
       hdmi_pixel_buf_first__2_BIT_0_3_EQ_hdmi_x_4_EQ_ETC___d107,
       hdmi_x_4_SLT_hdmi_vp_wget__9_BITS_15_TO_0_7_PL_ETC___d117;

  // oscillator and gates for output clock csi_clockreset_clk_coe_hdmi_dclk
  assign csi_clockreset_clk_coe_hdmi_dclk = csi_video_clk ;
  assign CLK_GATE_coe_hdmi_dclk = 1'd1 ;

  // action method avs_s0
  assign CAN_FIRE_avs_s0 = 1'd1 ;
  assign WILL_FIRE_avs_s0 = 1'd1 ;

  // value method avs_s0_readdata
  assign avs_s0_readdata =
	     vparams_mmap_slave_avalonwait_end_read$whas ?
	       b__h4883 :
	       32'hDEADDEAD ;

  // value method avs_s0_waitrequest
  assign avs_s0_waitrequest =
	     avs_s0_read && !vparams_mmap_slave_avalonwait_end_read$whas ||
	     avs_s0_write && !vparams_mmap_slave_avalonwait_end_write$whas ;

  // action method avm_m0
  assign CAN_FIRE_avm_m0 = 1'd1 ;
  assign WILL_FIRE_avm_m0 = 1'd1 ;

  // value method avm_m0_writedata
  assign avm_m0_writedata = burst_read$avalon_master_phy_m0_writedata ;

  // value method avm_m0_address
  assign avm_m0_address = burst_read$avalon_master_phy_m0_address ;

  // value method avm_m0_read
  assign avm_m0_read = burst_read$avalon_master_phy_m0_read ;

  // value method avm_m0_write
  assign avm_m0_write = burst_read$avalon_master_phy_m0_write ;

  // value method avm_m0_burstcount
  assign avm_m0_burstcount = burst_read$avalon_master_phy_m0_burstcount ;

  // value method coe_hdmi_r
  assign coe_hdmi_r = hdmi_pixel_out[8:1] ;

  // value method coe_hdmi_g
  assign coe_hdmi_g = hdmi_pixel_out[16:9] ;

  // value method coe_hdmi_b
  assign coe_hdmi_b = hdmi_pixel_out[24:17] ;

  // value method coe_hdmi_hsd
  assign coe_hdmi_hsd = hdmi_hsd ;

  // value method coe_hdmi_vsd
  assign coe_hdmi_vsd = hdmi_vsd ;

  // value method coe_hdmi_de
  assign coe_hdmi_de = hdmi_de ;

  // submodule burst_read
  mkBurstRead burst_read(.CLK(csi_clockreset_clk),
			 .RST_N(csi_clockreset_reset_n),
			 .avalon_master_phy_m0_readdata(burst_read$avalon_master_phy_m0_readdata),
			 .avalon_master_phy_m0_readdatavalid(burst_read$avalon_master_phy_m0_readdatavalid),
			 .avalon_master_phy_m0_waitrequest(burst_read$avalon_master_phy_m0_waitrequest),
			 .params_base(burst_read$params_base),
			 .params_number_pixels(burst_read$params_number_pixels),
			 .EN_pixel_stream_get(burst_read$EN_pixel_stream_get),
			 .EN_params(burst_read$EN_params),
			 .avalon_master_phy_m0_writedata(burst_read$avalon_master_phy_m0_writedata),
			 .avalon_master_phy_m0_address(burst_read$avalon_master_phy_m0_address),
			 .avalon_master_phy_m0_read(burst_read$avalon_master_phy_m0_read),
			 .avalon_master_phy_m0_write(burst_read$avalon_master_phy_m0_write),
			 .avalon_master_phy_m0_burstcount(burst_read$avalon_master_phy_m0_burstcount),
			 .pixel_stream_get(burst_read$pixel_stream_get),
			 .RDY_pixel_stream_get(burst_read$RDY_pixel_stream_get),
			 .RDY_params());

  // submodule hdmi_pixel_buf
  SizedFIFO #(.p1width(32'd25),
	      .p2depth(32'd64),
	      .p3cntr_width(32'd6),
	      .guarded(32'd1)) hdmi_pixel_buf(.RST(vidrst$OUT_RST),
					      .CLK(csi_video_clk),
					      .D_IN(hdmi_pixel_buf$D_IN),
					      .ENQ(hdmi_pixel_buf$ENQ),
					      .DEQ(hdmi_pixel_buf$DEQ),
					      .CLR(hdmi_pixel_buf$CLR),
					      .D_OUT(hdmi_pixel_buf$D_OUT),
					      .FULL_N(hdmi_pixel_buf$FULL_N),
					      .EMPTY_N(hdmi_pixel_buf$EMPTY_N));

  // submodule pix_sync
  SyncFIFO #(.dataWidth(32'd25),
	     .depth(32'd256),
	     .indxWidth(32'd8)) pix_sync(.sCLK(csi_clockreset_clk),
					 .dCLK(csi_video_clk),
					 .sRST(csi_clockreset_reset_n),
					 .sD_IN(pix_sync$sD_IN),
					 .sENQ(pix_sync$sENQ),
					 .dDEQ(pix_sync$dDEQ),
					 .sFULL_N(pix_sync$sFULL_N),
					 .dEMPTY_N(pix_sync$dEMPTY_N),
					 .dD_OUT(pix_sync$dD_OUT));

  // submodule vidrst
  SyncResetA #(.RSTDELAY(32'd1)) vidrst(.CLK(csi_video_clk),
					.IN_RST(csi_clockreset_reset_n),
					.OUT_RST(vidrst$OUT_RST));

  // submodule vp_sync
  SyncRegister #(.width(32'd128),
		 .init(128'd0)) vp_sync(.sCLK(csi_clockreset_clk),
					.dCLK(csi_video_clk),
					.sRST(csi_clockreset_reset_n),
					.sD_IN(vp_sync$sD_IN),
					.sEN(vp_sync$sEN),
					.sRDY(vp_sync$sRDY),
					.dD_OUT(vp_sync$dD_OUT));

  // submodule vparams_mmap_slave_outbuf
  FIFO2 #(.width(32'd38),
	  .guarded(32'd1)) vparams_mmap_slave_outbuf(.RST(csi_clockreset_reset_n),
						     .CLK(csi_clockreset_clk),
						     .D_IN(vparams_mmap_slave_outbuf$D_IN),
						     .ENQ(vparams_mmap_slave_outbuf$ENQ),
						     .DEQ(vparams_mmap_slave_outbuf$DEQ),
						     .CLR(vparams_mmap_slave_outbuf$CLR),
						     .D_OUT(vparams_mmap_slave_outbuf$D_OUT),
						     .FULL_N(vparams_mmap_slave_outbuf$FULL_N),
						     .EMPTY_N(vparams_mmap_slave_outbuf$EMPTY_N));

  // rule RL_mkConnectionGetPut
  assign CAN_FIRE_RL_mkConnectionGetPut =
	     pix_sync$sFULL_N && burst_read$RDY_pixel_stream_get ;
  assign WILL_FIRE_RL_mkConnectionGetPut = CAN_FIRE_RL_mkConnectionGetPut ;

  // rule RL_forward_burst_params
  assign CAN_FIRE_RL_forward_burst_params = 1'd1 ;
  assign WILL_FIRE_RL_forward_burst_params = 1'd1 ;

  // rule RL_forward_parameters_local_clock
  assign CAN_FIRE_RL_forward_parameters_local_clock = vp_sync$sRDY ;
  assign WILL_FIRE_RL_forward_parameters_local_clock = vp_sync$sRDY ;

  // rule RL_forward_parameters_video_clock
  assign CAN_FIRE_RL_forward_parameters_video_clock = 1'd1 ;
  assign WILL_FIRE_RL_forward_parameters_video_clock = 1'd1 ;

  // rule RL_vparams_handle_avalon_accesses
  assign CAN_FIRE_RL_vparams_handle_avalon_accesses =
	     vparams_mmap_slave_outbuf$EMPTY_N ;
  assign WILL_FIRE_RL_vparams_handle_avalon_accesses =
	     vparams_mmap_slave_outbuf$EMPTY_N ;

  // rule RL_vparams_mmap_slave_hanlde_bus_requests
  assign CAN_FIRE_RL_vparams_mmap_slave_hanlde_bus_requests =
	     vparams_mmap_slave_outbuf$FULL_N &&
	     (avs_s0_read || avs_s0_write) &&
	     !vparams_mmap_slave_ignore_further_requests ;
  assign WILL_FIRE_RL_vparams_mmap_slave_hanlde_bus_requests =
	     CAN_FIRE_RL_vparams_mmap_slave_hanlde_bus_requests ;

  // rule RL_vparams_mmap_slave_wire_up_avalonwait
  assign CAN_FIRE_RL_vparams_mmap_slave_wire_up_avalonwait = 1'd1 ;
  assign WILL_FIRE_RL_vparams_mmap_slave_wire_up_avalonwait = 1'd1 ;

  // rule RL_vparams_mmap_slave_cancel_ingore_further_requests
  assign CAN_FIRE_RL_vparams_mmap_slave_cancel_ingore_further_requests =
	     !vparams_mmap_slave_avalonwait$wget &&
	     vparams_mmap_slave_ignore_further_requests ;
  assign WILL_FIRE_RL_vparams_mmap_slave_cancel_ingore_further_requests =
	     CAN_FIRE_RL_vparams_mmap_slave_cancel_ingore_further_requests ;

  // rule RL_hdmi_init
  assign CAN_FIRE_RL_hdmi_init = hdmi_pixel_buf$EMPTY_N && !hdmi_output_on ;
  assign WILL_FIRE_RL_hdmi_init = CAN_FIRE_RL_hdmi_init ;

  // rule RL_hdmi_scan
  assign CAN_FIRE_RL_hdmi_scan = hdmi_output_on ;
  assign WILL_FIRE_RL_hdmi_scan = hdmi_output_on ;

  // rule RL_mkConnectionGetPut_1
  assign CAN_FIRE_RL_mkConnectionGetPut_1 =
	     pix_sync$dEMPTY_N && hdmi_pixel_buf$FULL_N ;
  assign WILL_FIRE_RL_mkConnectionGetPut_1 =
	     CAN_FIRE_RL_mkConnectionGetPut_1 ;

  // inlined wires
  assign vparams_mmap_slave_avalonwait_end_read$whas =
	     vparams_mmap_slave_outbuf$EMPTY_N &&
	     vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd0 ;
  assign vparams_mmap_slave_avalonwait_end_write$whas =
	     WILL_FIRE_RL_vparams_mmap_slave_hanlde_bus_requests &&
	     avs_s0_write ;
  assign vparams_mmap_slave_avalonwait$wget =
	     avs_s0_read && !vparams_mmap_slave_avalonwait_end_read$whas ||
	     avs_s0_write && !vparams_mmap_slave_avalonwait_end_write$whas ;

  // register hdmi_de
  assign hdmi_de$D_IN =
	     NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_hdmi_ETC___d145 ;
  assign hdmi_de$EN = hdmi_output_on ;

  // register hdmi_hsd
  assign hdmi_hsd$D_IN =
	     (hdmi_x ^ 16'h8000) >= (-vp_sync$dD_OUT[47:32] ^ 16'h8000) ;
  assign hdmi_hsd$EN = hdmi_output_on ;

  // register hdmi_output_on
  assign hdmi_output_on$D_IN = !hdmi_pixel_buf$FULL_N ;
  assign hdmi_output_on$EN =
	     WILL_FIRE_RL_hdmi_init && hdmi_pixel_buf$D_OUT[0] ;

  // register hdmi_pixel_out
  assign hdmi_pixel_out$D_IN =
	     { IF_NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_h_ETC___d152,
	       IF_NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_h_ETC___d155,
	       IF_NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_h_ETC___d158,
	       NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_hdmi_ETC___d145 &&
	       (!hdmi_pixel_buf$EMPTY_N ||
		!hdmi_pixel_buf_first__2_BIT_0_3_EQ_hdmi_x_4_EQ_ETC___d107 ||
		hdmi_pixel_buf$D_OUT[0]) } ;
  assign hdmi_pixel_out$EN = hdmi_output_on ;

  // register hdmi_vsd
  assign hdmi_vsd$D_IN =
	     (hdmi_y ^ 16'h8000) >= (-vp_sync$dD_OUT[111:96] ^ 16'h8000) ;
  assign hdmi_vsd$EN = hdmi_output_on ;

  // register hdmi_x
  assign hdmi_x$D_IN =
	     hdmi_x_4_SLT_hdmi_vp_wget__9_BITS_15_TO_0_7_PL_ETC___d117 ?
	       hdmi_x + 16'd1 :
	       -(vp_sync$dD_OUT[31:16] + vp_sync$dD_OUT[47:32]) ;
  assign hdmi_x$EN = hdmi_output_on ;

  // register hdmi_y
  assign hdmi_y$D_IN =
	     ((hdmi_y ^ 16'h8000) <
	      (vp_sync$dD_OUT[79:64] + vp_sync$dD_OUT[127:112] - 16'd1 ^
	       16'h8000)) ?
	       hdmi_y + 16'd1 :
	       -(vp_sync$dD_OUT[95:80] + vp_sync$dD_OUT[111:96]) ;
  assign hdmi_y$EN =
	     hdmi_output_on &&
	     !hdmi_x_4_SLT_hdmi_vp_wget__9_BITS_15_TO_0_7_PL_ETC___d117 ;

  // register num_pixels
  assign num_pixels$D_IN =
	     SEXT_vparams_p_0_6_74_MUL_SEXT_vparams_p_4_0_75___d176[31:0] ;
  assign num_pixels$EN = 1'd1 ;

  // register vparams_base
  assign vparams_base$D_IN =
	     (vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd8) ?
	       x__h2024 :
	       x__h2113 ;
  assign vparams_base$EN =
	     vparams_mmap_slave_outbuf$EMPTY_N &&
	     vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1 &&
	     (vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd8 ||
	      vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd9) ;

  // register vparams_mmap_slave_ignore_further_requests
  assign vparams_mmap_slave_ignore_further_requests$D_IN =
	     WILL_FIRE_RL_vparams_mmap_slave_hanlde_bus_requests &&
	     avs_s0_read ;
  assign vparams_mmap_slave_ignore_further_requests$EN =
	     WILL_FIRE_RL_vparams_mmap_slave_hanlde_bus_requests ||
	     WILL_FIRE_RL_vparams_mmap_slave_cancel_ingore_further_requests ;

  // register vparams_p_0
  assign vparams_p_0$D_IN = vparams_mmap_slave_outbuf$D_OUT[15:0] ;
  assign vparams_p_0$EN =
	     vparams_mmap_slave_outbuf$EMPTY_N &&
	     vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd0 &&
	     !vparams_mmap_slave_outbuf$D_OUT[35] &&
	     vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1 ;

  // register vparams_p_1
  assign vparams_p_1$D_IN = vparams_mmap_slave_outbuf$D_OUT[15:0] ;
  assign vparams_p_1$EN =
	     vparams_mmap_slave_outbuf$EMPTY_N &&
	     vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd1 &&
	     !vparams_mmap_slave_outbuf$D_OUT[35] &&
	     vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1 ;

  // register vparams_p_2
  assign vparams_p_2$D_IN = vparams_mmap_slave_outbuf$D_OUT[15:0] ;
  assign vparams_p_2$EN =
	     vparams_mmap_slave_outbuf$EMPTY_N &&
	     vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd2 &&
	     !vparams_mmap_slave_outbuf$D_OUT[35] &&
	     vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1 ;

  // register vparams_p_3
  assign vparams_p_3$D_IN = vparams_mmap_slave_outbuf$D_OUT[15:0] ;
  assign vparams_p_3$EN =
	     vparams_mmap_slave_outbuf$EMPTY_N &&
	     vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd3 &&
	     !vparams_mmap_slave_outbuf$D_OUT[35] &&
	     vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1 ;

  // register vparams_p_4
  assign vparams_p_4$D_IN = vparams_mmap_slave_outbuf$D_OUT[15:0] ;
  assign vparams_p_4$EN =
	     vparams_mmap_slave_outbuf$EMPTY_N &&
	     vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd4 &&
	     !vparams_mmap_slave_outbuf$D_OUT[35] &&
	     vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1 ;

  // register vparams_p_5
  assign vparams_p_5$D_IN = vparams_mmap_slave_outbuf$D_OUT[15:0] ;
  assign vparams_p_5$EN =
	     vparams_mmap_slave_outbuf$EMPTY_N &&
	     vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd5 &&
	     !vparams_mmap_slave_outbuf$D_OUT[35] &&
	     vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1 ;

  // register vparams_p_6
  assign vparams_p_6$D_IN = vparams_mmap_slave_outbuf$D_OUT[15:0] ;
  assign vparams_p_6$EN =
	     vparams_mmap_slave_outbuf$EMPTY_N &&
	     vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd6 &&
	     !vparams_mmap_slave_outbuf$D_OUT[35] &&
	     vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1 ;

  // register vparams_p_7
  assign vparams_p_7$D_IN = vparams_mmap_slave_outbuf$D_OUT[15:0] ;
  assign vparams_p_7$EN =
	     vparams_mmap_slave_outbuf$EMPTY_N &&
	     vparams_mmap_slave_outbuf$D_OUT[35:32] == 4'd7 &&
	     !vparams_mmap_slave_outbuf$D_OUT[35] &&
	     vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1 ;

  // submodule burst_read
  assign burst_read$avalon_master_phy_m0_readdata = avm_m0_readdata ;
  assign burst_read$avalon_master_phy_m0_readdatavalid =
	     avm_m0_readdatavalid ;
  assign burst_read$avalon_master_phy_m0_waitrequest = avm_m0_waitrequest ;
  assign burst_read$params_base = vparams_base ;
  assign burst_read$params_number_pixels = num_pixels ;
  assign burst_read$EN_pixel_stream_get = CAN_FIRE_RL_mkConnectionGetPut ;
  assign burst_read$EN_params = 1'd1 ;

  // submodule hdmi_pixel_buf
  assign hdmi_pixel_buf$D_IN = pix_sync$dD_OUT ;
  assign hdmi_pixel_buf$ENQ = CAN_FIRE_RL_mkConnectionGetPut_1 ;
  assign hdmi_pixel_buf$DEQ =
	     WILL_FIRE_RL_hdmi_init && !hdmi_pixel_buf$D_OUT[0] ||
	     hdmi_output_on &&
	     NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_hdmi_ETC___d145 &&
	     hdmi_pixel_buf$EMPTY_N &&
	     hdmi_pixel_buf_first__2_BIT_0_3_EQ_hdmi_x_4_EQ_ETC___d107 ;
  assign hdmi_pixel_buf$CLR = 1'b0 ;

  // submodule pix_sync
  assign pix_sync$sD_IN = burst_read$pixel_stream_get ;
  assign pix_sync$sENQ = CAN_FIRE_RL_mkConnectionGetPut ;
  assign pix_sync$dDEQ = CAN_FIRE_RL_mkConnectionGetPut_1 ;

  // submodule vp_sync
  assign vp_sync$sD_IN =
	     { vparams_p_7,
	       vparams_p_6,
	       vparams_p_5,
	       vparams_p_4,
	       vparams_p_3,
	       vparams_p_2,
	       vparams_p_1,
	       vparams_p_0 } ;
  assign vp_sync$sEN = vp_sync$sRDY ;

  // submodule vparams_mmap_slave_outbuf
  assign vparams_mmap_slave_outbuf$D_IN =
	     { avs_s0_read ? 2'd0 : 2'd1, avs_s0_address, avs_s0_writedata } ;
  assign vparams_mmap_slave_outbuf$ENQ =
	     CAN_FIRE_RL_vparams_mmap_slave_hanlde_bus_requests ;
  assign vparams_mmap_slave_outbuf$DEQ = vparams_mmap_slave_outbuf$EMPTY_N ;
  assign vparams_mmap_slave_outbuf$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_h_ETC___d152 =
	     NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_hdmi_ETC___d145 ?
	       ((hdmi_pixel_buf$EMPTY_N &&
		 hdmi_pixel_buf_first__2_BIT_0_3_EQ_hdmi_x_4_EQ_ETC___d107) ?
		  hdmi_pixel_buf$D_OUT[24:17] :
		  8'd0) :
	       8'd0 ;
  assign IF_NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_h_ETC___d155 =
	     NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_hdmi_ETC___d145 ?
	       ((hdmi_pixel_buf$EMPTY_N &&
		 hdmi_pixel_buf_first__2_BIT_0_3_EQ_hdmi_x_4_EQ_ETC___d107) ?
		  hdmi_pixel_buf$D_OUT[16:9] :
		  8'd0) :
	       8'd0 ;
  assign IF_NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_h_ETC___d158 =
	     NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_hdmi_ETC___d145 ?
	       ((hdmi_pixel_buf$EMPTY_N &&
		 hdmi_pixel_buf_first__2_BIT_0_3_EQ_hdmi_x_4_EQ_ETC___d107) ?
		  hdmi_pixel_buf$D_OUT[8:1] :
		  8'd255) :
	       8'd0 ;
  assign NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_hdmi_ETC___d145 =
	     !hdmi_y[15] &&
	     (hdmi_y ^ 16'h8000) < (vp_sync$dD_OUT[79:64] ^ 16'h8000) &&
	     !hdmi_x[15] &&
	     (hdmi_x ^ 16'h8000) < (vp_sync$dD_OUT[15:0] ^ 16'h8000) ;
  assign SEXT_vparams_p_0_6_74_MUL_SEXT_vparams_p_4_0_75___d176 =
	     { {16{vparams_p_0[15]}}, vparams_p_0 } *
	     { {16{vparams_p_4[15]}}, vparams_p_4 } ;
  assign b__h4883 =
	     vparams_mmap_slave_outbuf$D_OUT[35] ?
	       CASE_vparams_mmap_slave_outbufD_OUT_BITS_35_T_ETC__q1 :
	       { 16'd0, x__h2347 } ;
  assign hdmi_pixel_buf_first__2_BIT_0_3_EQ_hdmi_x_4_EQ_ETC___d107 =
	     hdmi_pixel_buf$D_OUT[0] == (hdmi_x == 16'd0 && hdmi_y == 16'd0) ;
  assign hdmi_x_4_SLT_hdmi_vp_wget__9_BITS_15_TO_0_7_PL_ETC___d117 =
	     (hdmi_x ^ 16'h8000) <
	     (vp_sync$dD_OUT[15:0] + vp_sync$dD_OUT[63:48] - 16'd1 ^
	      16'h8000) ;
  assign x__h2024 =
	     { vparams_base[63:32], vparams_mmap_slave_outbuf$D_OUT[31:0] } ;
  assign x__h2113 =
	     { vparams_mmap_slave_outbuf$D_OUT[31:0], vparams_base[31:0] } ;
  always@(vparams_mmap_slave_outbuf$D_OUT or
	  vparams_p_0 or
	  vparams_p_1 or
	  vparams_p_2 or
	  vparams_p_3 or
	  vparams_p_4 or vparams_p_5 or vparams_p_6 or vparams_p_7)
  begin
    case (vparams_mmap_slave_outbuf$D_OUT[35:32])
      4'd0: x__h2347 = vparams_p_0;
      4'd1: x__h2347 = vparams_p_1;
      4'd2: x__h2347 = vparams_p_2;
      4'd3: x__h2347 = vparams_p_3;
      4'd4: x__h2347 = vparams_p_4;
      4'd5: x__h2347 = vparams_p_5;
      4'd6: x__h2347 = vparams_p_6;
      4'd7: x__h2347 = vparams_p_7;
      default: x__h2347 = 16'b1010101010101010 /* unspecified value */ ;
    endcase
  end
  always@(vparams_mmap_slave_outbuf$D_OUT or vparams_base)
  begin
    case (vparams_mmap_slave_outbuf$D_OUT[35:32])
      4'd8:
	  CASE_vparams_mmap_slave_outbufD_OUT_BITS_35_T_ETC__q1 =
	      vparams_base[31:0];
      4'd9:
	  CASE_vparams_mmap_slave_outbufD_OUT_BITS_35_T_ETC__q1 =
	      vparams_base[63:32];
      default: CASE_vparams_mmap_slave_outbufD_OUT_BITS_35_T_ETC__q1 =
		   32'hFFFFFFFF;
    endcase
  end

  // handling of inlined registers

  always@(posedge csi_clockreset_clk)
  begin
    if (csi_clockreset_reset_n == `BSV_RESET_VALUE)
      begin
        num_pixels <= `BSV_ASSIGNMENT_DELAY 32'd0;
	vparams_base <= `BSV_ASSIGNMENT_DELAY 64'h0000000008000000;
	vparams_mmap_slave_ignore_further_requests <= `BSV_ASSIGNMENT_DELAY
	    1'd0;
	vparams_p_0 <= `BSV_ASSIGNMENT_DELAY 16'd480;
	vparams_p_1 <= `BSV_ASSIGNMENT_DELAY 16'd41;
	vparams_p_2 <= `BSV_ASSIGNMENT_DELAY 16'd88;
	vparams_p_3 <= `BSV_ASSIGNMENT_DELAY 16'd8;
	vparams_p_4 <= `BSV_ASSIGNMENT_DELAY 16'd272;
	vparams_p_5 <= `BSV_ASSIGNMENT_DELAY 16'd10;
	vparams_p_6 <= `BSV_ASSIGNMENT_DELAY 16'd12;
	vparams_p_7 <= `BSV_ASSIGNMENT_DELAY 16'd3;
      end
    else
      begin
        if (num_pixels$EN)
	  num_pixels <= `BSV_ASSIGNMENT_DELAY num_pixels$D_IN;
	if (vparams_base$EN)
	  vparams_base <= `BSV_ASSIGNMENT_DELAY vparams_base$D_IN;
	if (vparams_mmap_slave_ignore_further_requests$EN)
	  vparams_mmap_slave_ignore_further_requests <= `BSV_ASSIGNMENT_DELAY
	      vparams_mmap_slave_ignore_further_requests$D_IN;
	if (vparams_p_0$EN)
	  vparams_p_0 <= `BSV_ASSIGNMENT_DELAY vparams_p_0$D_IN;
	if (vparams_p_1$EN)
	  vparams_p_1 <= `BSV_ASSIGNMENT_DELAY vparams_p_1$D_IN;
	if (vparams_p_2$EN)
	  vparams_p_2 <= `BSV_ASSIGNMENT_DELAY vparams_p_2$D_IN;
	if (vparams_p_3$EN)
	  vparams_p_3 <= `BSV_ASSIGNMENT_DELAY vparams_p_3$D_IN;
	if (vparams_p_4$EN)
	  vparams_p_4 <= `BSV_ASSIGNMENT_DELAY vparams_p_4$D_IN;
	if (vparams_p_5$EN)
	  vparams_p_5 <= `BSV_ASSIGNMENT_DELAY vparams_p_5$D_IN;
	if (vparams_p_6$EN)
	  vparams_p_6 <= `BSV_ASSIGNMENT_DELAY vparams_p_6$D_IN;
	if (vparams_p_7$EN)
	  vparams_p_7 <= `BSV_ASSIGNMENT_DELAY vparams_p_7$D_IN;
      end
  end

  always@(posedge csi_video_clk)
  begin
    if (vidrst$OUT_RST == `BSV_RESET_VALUE)
      begin
        hdmi_output_on <= `BSV_ASSIGNMENT_DELAY 1'd0;
	hdmi_x <= `BSV_ASSIGNMENT_DELAY 16'd0;
	hdmi_y <= `BSV_ASSIGNMENT_DELAY 16'd0;
      end
    else
      begin
        if (hdmi_output_on$EN)
	  hdmi_output_on <= `BSV_ASSIGNMENT_DELAY hdmi_output_on$D_IN;
	if (hdmi_x$EN) hdmi_x <= `BSV_ASSIGNMENT_DELAY hdmi_x$D_IN;
	if (hdmi_y$EN) hdmi_y <= `BSV_ASSIGNMENT_DELAY hdmi_y$D_IN;
      end
    if (hdmi_de$EN) hdmi_de <= `BSV_ASSIGNMENT_DELAY hdmi_de$D_IN;
    if (hdmi_hsd$EN) hdmi_hsd <= `BSV_ASSIGNMENT_DELAY hdmi_hsd$D_IN;
    if (hdmi_pixel_out$EN)
      hdmi_pixel_out <= `BSV_ASSIGNMENT_DELAY hdmi_pixel_out$D_IN;
    if (hdmi_vsd$EN) hdmi_vsd <= `BSV_ASSIGNMENT_DELAY hdmi_vsd$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    hdmi_de = 1'h0;
    hdmi_hsd = 1'h0;
    hdmi_output_on = 1'h0;
    hdmi_pixel_out = 25'h0AAAAAA;
    hdmi_vsd = 1'h0;
    hdmi_x = 16'hAAAA;
    hdmi_y = 16'hAAAA;
    num_pixels = 32'hAAAAAAAA;
    vparams_base = 64'hAAAAAAAAAAAAAAAA;
    vparams_mmap_slave_ignore_further_requests = 1'h0;
    vparams_p_0 = 16'hAAAA;
    vparams_p_1 = 16'hAAAA;
    vparams_p_2 = 16'hAAAA;
    vparams_p_3 = 16'hAAAA;
    vparams_p_4 = 16'hAAAA;
    vparams_p_5 = 16'hAAAA;
    vparams_p_6 = 16'hAAAA;
    vparams_p_7 = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge csi_clockreset_clk)
  begin
    #0;
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (vparams_mmap_slave_outbuf$EMPTY_N &&
	  !vparams_mmap_slave_outbuf$D_OUT[35] &&
	  vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1)
	begin
	  v__h1935 = $time;
	  #0;
	end
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (vparams_mmap_slave_outbuf$EMPTY_N &&
	  !vparams_mmap_slave_outbuf$D_OUT[35] &&
	  vparams_mmap_slave_outbuf$D_OUT[37:36] == 2'd1)
	$display("%05t: VideoParameter[%d]=%d",
		 v__h1935,
		 $unsigned(vparams_mmap_slave_outbuf$D_OUT[35:32]),
		 $unsigned(vparams_mmap_slave_outbuf$D_OUT[31:0]));
  end
  // synopsys translate_on

  // synopsys translate_off
  always@(negedge csi_video_clk)
  begin
    #0;
    if (vidrst$OUT_RST != `BSV_RESET_VALUE)
      if (hdmi_output_on &&
	  NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_hdmi_ETC___d145 &&
	  (!hdmi_pixel_buf$EMPTY_N ||
	   !hdmi_pixel_buf_first__2_BIT_0_3_EQ_hdmi_x_4_EQ_ETC___d107))
	begin
	  v__h3787 = $time;
	  #0;
	end
    if (vidrst$OUT_RST != `BSV_RESET_VALUE)
      if (hdmi_output_on &&
	  NOT_hdmi_y_7_BIT_15_8_41_AND_hdmi_y_7_SLT_hdmi_ETC___d145 &&
	  (!hdmi_pixel_buf$EMPTY_N ||
	   !hdmi_pixel_buf_first__2_BIT_0_3_EQ_hdmi_x_4_EQ_ETC___d107))
	$display("%05t: WARNING: pixel buffer is empty - drawing red",
		 v__h3787);
  end
  // synopsys translate_on
endmodule  // mkPixelStream

